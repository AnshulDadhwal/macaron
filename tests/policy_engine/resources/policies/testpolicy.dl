/* Copyright (c) 2023 - 2023, Oracle and/or its affiliates. All rights reserved. */
/* Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl/. */


/* ----------------------------- prelude ----------------------------------- */

#define none(x) 0 = count: {x}

.decl seq(n: number)
seq(0).
seq(n+1) :- n <= 10, seq(n).


.decl Policy(policy_id: symbol, repo: number, message: symbol)
.decl apply_policy_to(policy_id: symbol, repo: number)

.decl ArtefactPolicy(policy_id: symbol, artefact: number, message: symbol)
.decl apply_artefact_policy_to(policy_id: symbol, repo: number)

.decl failed_artefact_policies(policy_id: symbol, artefact: number)

.decl check_passed(repo: number, check_name: symbol)
check_passed(repo, check_name) :- check_result(_, check_name, repo, 1, skipped).

.decl check_skipped(repo: number, check_name: symbol)
check_skipped(repo, check_name) :- check_result(_, check_name, repo, passed, 1).

failed_artefact_policies(policy_id, artefact) :-
    apply_artefact_policy_to(policy_id, artefact),
    !ArtefactPolicy(policy_id, artefact, _).


.decl passed_artefact_policies(policy_id:symbol, artefact:number, msg:symbol)
passed_artefact_policies(policy_id, artefact, msg):-
    ArtefactPolicy(policy_id, artefact, msg),
    // policy passes on all artefacts it applies to
    0 = count: {failed_artefact_policies(policy_id, _)}.

//.output failed_artefact_policies
//.output passed_artefact_policies

/* for outputting debugging information or feedback */
.decl failed_policies(policy_id:symbol, repo:number)
// policy applies to the repo and failed
failed_policies(policy_id, repo) :-
    apply_policy_to(policy_id, repo),
    !Policy(policy_id, repo, _).


.decl passed_policies(policy_id:symbol, repo:number, msg:symbol)
passed_policies(policy_id, repo, msg):-
    Policy(policy_id, repo, msg),
    // policy passes on all repos it applies to
    0 = count: {failed_policies(policy_id, _)}.


/* ----------------------------- helper rules ------------------------------- */


.decl rule(repo:number, feedback:symbol)
rule(repo, feedback) :- slsa_requirement(repo, _, "Version controlled", fa),
                    slsa_requirement(repo, _, "Scripted Build", fb),
                    slsa_requirement(repo, _, "Build service", fc),
                    slsa_requirement(repo, _, "Build as code", fd),
                    check_passed(repo, "trusted_builder_check"),
                    check_passed(repo, "provenance_available_check"),
                    check_passed(repo, "build_as_code_check"),
                    feedback = cat(cat(cat(cat(fa, fb), fc), fd)).

.decl not_self_hosted_git(repo:number, message:symbol)
not_self_hosted_git(repo, message) :- repository(repo, name, remote, branch, release, commit_sha, commit_date),
    match("^.*(github.com|gitlab.com).*$", remote), message=remote.


.decl accept(repo:number, feedback:symbol)
accept(repo, feedback) :-
        repository(repo, _,_,_,_,_,_),
        rule(repo, feedback),
        all(dependency(repo, _),
            (dependency(repo, dep), rule(dep, _))).

Policy("trusted_git_server", repo, reponame) :-
        repository(repo, reponame,_,_,_,_,_),
        not_self_hosted_git(repo, _).

apply_policy_to("trusted_git_server", repo) :- repository(repo, _,_,_,_,_,_).

.decl is_trusted_builder_typeuri(builder_id:symbol)
is_trusted_builder_typeuri(builder) :-  provenance(_, _, _, _, _, builder, _, _, _),
                                match("https://github.com/slsa-framework/slsa-github-generator/.github/workflows/builder_go_slsa3.yml@refs/tags/v1.[2-9]+.[0-9]+", builder).


/* ------------------------------- policies ------------------------------- */

/** METADATA
 *  scope: repository
 *  title: Trusted Builder
 *  description: Repository builds artefacts using a trusted builder, a trusted
 *      builder; github actions.
 *  threat:
 *      Trusted builders are trusted to implement ephemerality, isolation ...
 *      of their build systems.
    fix: Build using github actions
 */
Policy("trusted_builder", repo, name) :-
        repository(repo, name,_,_,_,_,_),
        provenance(prov, repo, _, _, _, builder, _, _, _),
        is_trusted_builder_typeuri(builder).


Policy("trusted_builder", repo, name) :-
        repository(repo, name,_,_,_,_,_),
        check_passed(repo, "mcn_trusted_builder_level_three_1").

Policy("trusted_builder", repo, name) :-
        repository(repo, name,_,_,_,_,_),
        build_service_check(build_tool_name, ci_service, build_trigger,
        result_id, result, repo),
        passed = 1,
        match("github-actions", build_tool_name).

Policy("trusted_builder", repo, name) :-
        repository(repo, name,_,_,_,_,_),
        build_script_check(build_tool_name, result_id, result, repo),
        passed = 1,
        match("github-actions", build_tool_name).


apply_policy_to("trusted_builder", repo) :-
    repository(repo, name,_,_,_,_,_),
    provenance(prov, repo, _, _, _, _, _, _, _).

apply_policy_to("specific_rule", repo) :-
    repository(repo, name,_,_,_,_,_).


ArtefactPolicy("repopolicies", artefact, info) :-
    provenance(prov, repo, _, _, _, _, _, _, _),
    provenance_artefact(artefact, info, verified, prov),
    verified = 1,
    !failed_policies(_, repo).


apply_artefact_policy_to("repopolicies", artefact) :-
    provenance_artefact(artefact, _, _, _).


// Rule that applies to a specific repository and passes all others
Policy("specific_rule", repo, feedback) :-
            repository(repo, name,_,_,_,_,_),
            accept(repo, result), feedback = cat(cat(name, ":  "), result).


/* aggregate verifying a level */
.decl aggregate_level(level: number, repo: number)
.decl aggregate_level_requirement(level: number, repo: number)
.decl aggregate_level_dependency_requirement(level: number, repo: number)

/* Everything has a repository */
aggregate_level_requirement(1, repo) :-
    repository(repo, _,_,_,_,_,_),
    check_passed(repo, "mcn_build_script_1"),
    check_passed(repo, "mcn_version_control_system_1").

aggregate_level_dependency_requirement(1, repo)  :-
    aggregate_level_requirement(1, repo).


aggregate_level_requirement(2, repo) :-
    repository(repo, _,_,_,_,_,_),
    check_passed(repo, "mcn_build_script_1"),
    check_passed(repo, "mcn_build_as_code_1"),
    check_passed(repo, "mcn_provenance_available_1").


aggregate_level_dependency_requirement(2, repo)  :-
    aggregate_level_requirement(1, repo).


aggregate_level_requirement(3, repo) :-
    repository(repo, _,_,_,_,_,_),
    check_passed(repo, "mcn_provenance_level_three_1"),
    Policy("trusted_builder", repo, name).


aggregate_level_dependency_requirement(3, repo)  :-
    aggregate_level_requirement(2, repo),
    aggregate_level_requirement(1, repo).


aggregate_level_dependency_requirement(3, repo)  :-
    aggregate_level_requirement(2, repo),
    aggregate_level_requirement(1, repo).

aggregate_level_requirement(4, repo) :-
    repository(repo, _,_,_,_,_,_),
    check_passed(repo, "mcn_provenance_level_three_1"),
    check_passed(repo, "mcn_trusted_builder_level_three_1"),
    Policy("trusted_git_server", repo, _).

aggregate_level_dependency_requirement(4, repo) :-
    aggregate_level_requirement(4, repo).


/* ------------------------------------------------------------------------- */

aggregate_level_dependency_requirement(0, repo) :-
    repository(repo, _,_,_,_,_,_).

aggregate_level(0, repo) :-
    repository(repo, _,_,_,_,_,_).

aggregate_level(level, repo) :-
    repository(repo, name,_,_,_,_,_),
    seq(level), level <= 4, level >= 1,
    aggregate_level(level - 1, repo),
    aggregate_level_requirement(level, repo),
    // requirements met for all levels below
    // all deps have requirements for all levels below
    none((dependency(repo, dep), n <= level, seq(n),
        !aggregate_level_dependency_requirement(n, dep))).


.output passed_policies
.output failed_policies
// .output aggregate_level
//.output check_passed
