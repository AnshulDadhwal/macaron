/* Copyright (c) 2023 - 2023, Oracle and/or its affiliates. All rights reserved. */
/* Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl/. */


/* ----------------------------- prelude ----------------------------------- */

.functor print_number(x:number) : number

.decl agg_levels(n: number)
agg_levels(0).
agg_levels(n+1) :- n <= 4, agg_levels(n).


.decl Policy(policy_id: symbol, repo: number, message: symbol)
.decl apply_policy_to(policy_id: symbol, repo: number)

.decl ArtefactPolicy(policy_id: symbol, artefact: number, message: symbol)
.decl apply_artefact_policy_to(policy_id: symbol, repo: number)

.decl failed_artefact_policies(policy_id: symbol, artefact: number)

.decl check_passed(repo: number, check_name: symbol)
check_passed(repo, check_name) :- check_result(_, check_name, repo, 1, skipped).

.decl check_skipped(repo: number, check_name: symbol)
check_skipped(repo, check_name) :- check_result(_, check_name, repo, passed, 1).

failed_artefact_policies(policy_id, artefact) :-
    apply_artefact_policy_to(policy_id, artefact),
    !ArtefactPolicy(policy_id, artefact, _).


.decl passed_artefact_policies(policy_id:symbol, artefact:number, msg:symbol)
passed_artefact_policies(policy_id, artefact, msg):-
    ArtefactPolicy(policy_id, artefact, msg),
    // policy passes on all artefacts it applies to
    0 = count: {failed_artefact_policies(policy_id, _)}.

//.output failed_artefact_policies
//.output passed_artefact_policies

/* for outputting debugging information or feedback */
.decl failed_policies(policy_id:symbol, repo:number)
// policy applies to the repo and failed
failed_policies(policy_id, repo) :-
    apply_policy_to(policy_id, repo),
    !Policy(policy_id, repo, _).


.decl passed_policies(policy_id:symbol, repo:number, msg:symbol)
passed_policies(policy_id, repo, msg):-
    Policy(policy_id, repo, msg),
    // policy passes on all repos it applies to
    0 = count: {failed_policies(policy_id, _)}.


/* ----------------------------- helper rules ------------------------------- */


.decl rule(repo:number, feedback:symbol)
rule(repo, feedback) :- slsa_requirement(repo, _, "Version controlled", fa),
                    slsa_requirement(repo, _, "Scripted Build", fb),
                    slsa_requirement(repo, _, "Build service", fc),
                    slsa_requirement(repo, _, "Build as code", fd),
                    check_passed(repo, "trusted_builder_check"),
                    check_passed(repo, "provenance_available_check"),
                    check_passed(repo, "build_as_code_check"),
                    feedback = cat(cat(cat(cat(fa, fb), fc), fd)).

.decl not_self_hosted_git(repo:number, message:symbol)
not_self_hosted_git(repo, message) :- repository(repo, name, remote, branch, release, commit_sha, commit_date),
    match("^.*(github.com|gitlab.com).*$", remote), message=remote.


.decl accept(repo:number, feedback:symbol)
accept(repo, feedback) :-
        repository(repo, _,_,_,_,_,_),
        rule(repo, feedback),
        all(dependency(repo, _),
            (dependency(repo, dep), rule(dep, _))).

Policy("trusted_git_server", repo, reponame) :-
        repository(repo, reponame,_,_,_,_,_),
        not_self_hosted_git(repo, _).

apply_policy_to("trusted_git_server", repo) :- repository(repo, _,_,_,_,_,_).

.decl is_trusted_builder_typeuri(builder_id:symbol)
is_trusted_builder_typeuri(builder) :-  provenance(_, _, _, _, _, builder, _, _, _),
                                match("https://github.com/slsa-framework/slsa-github-generator/.github/workflows/builder_go_slsa3.yml@refs/tags/v1.[2-9]+.[0-9]+", builder).


/* ------------------------------- policies ------------------------------- */

/** METADATA
 *  scope: repository
 *  title: Trusted Builder
 *  description: Repository builds artefacts using a trusted builder, a trusted
 *      builder; github actions.
 *  threat:
 *      Trusted builders are trusted to implement ephemerality, isolation ...
 *      of their build systems.
    fix: Build using github actions
 */
Policy("trusted_builder", repo, name) :-
        repository(repo, name,_,_,_,_,_),
        provenance(prov, repo, _, _, _, builder, _, _, _),
        is_trusted_builder_typeuri(builder).


Policy("trusted_builder", repo, name) :-
        repository(repo, name,_,_,_,_,_),
        check_passed(repo, "mcn_trusted_builder_level_three_1").

Policy("trusted_builder", repo, name) :-
        repository(repo, name,_,_,_,_,_),
        build_service_check(build_tool_name, ci_service, build_trigger,
        result_id, result, repo),
        passed = 1,
        match("github-actions", build_tool_name).

Policy("trusted_builder", repo, name) :-
        repository(repo, name,_,_,_,_,_),
        build_script_check(build_tool_name, result_id, result, repo),
        passed = 1,
        match("github-actions", build_tool_name).


apply_policy_to("trusted_builder", repo) :-
    repository(repo, name,_,_,_,_,_),
    provenance(prov, repo, _, _, _, _, _, _, _).

apply_policy_to("specific_rule", repo) :-
    repository(repo, name,_,_,_,_,_).


ArtefactPolicy("repopolicies", artefact, info) :-
    provenance(prov, repo, _, _, _, _, _, _, _),
    provenance_artefact(artefact, info, verified, prov),
    verified = 1,
    !failed_policies(_, repo).


apply_artefact_policy_to("repopolicies", artefact) :-
    provenance_artefact(artefact, _, _, _).


// Rule that applies to a specific repository and passes all others
Policy("specific_rule", repo, feedback) :-
            repository(repo, name,_,_,_,_,_),
            accept(repo, result), feedback = cat(cat(name, ":  "), result).


/* aggregate verifying a level */
.decl aggregate_level(level: number, repo: number)
.decl aggregate_level_requirement(level: number, repo: number)

/* Everything has a repository and uses a scripted build service. */
aggregate_level_requirement(1, repo) :-
    repository(repo, _,_,_,_,_,_),
    check_passed(repo, "mcn_build_service_1"),
    check_passed(repo, "mcn_version_control_system_1").



/**
    The build is verifiably automated and .
 */
aggregate_level_requirement(2, repo) :-
    repository(repo, _,_,_,_,_,_),
    check_passed(repo, "mcn_build_script_1"),
    check_passed(repo, "mcn_build_service_1"),
    check_passed(repo, "mcn_build_as_code_1").


.decl aggregate_level_min_dependency_level(level: number, dep_level:number)
aggregate_level_min_dependency_level(1, 1).
aggregate_level_min_dependency_level(2, 2).
aggregate_level_min_dependency_level(3, 2).
aggregate_level_min_dependency_level(4, 4).


/**
 *  The repository uses a trusted build service that outputs verifiable
 *   provenance information.
 */
aggregate_level_requirement(3, repo) :-
    repository(repo, _,_,_,_,_,_),
    check_passed(repo, "mcn_provenance_level_three_1"),
    aggregate_level_requirement(2, repo),
    aggregate_level_requirement(1, repo).


/**
 *   The release provenance verifies
 */
aggregate_level_requirement(4, repo) :-
    repository(repo, _,_,_,_,_,_),
    check_passed(repo, "mcn_provenance_level_three_1"),
    check_passed(repo, "mcn_trusted_builder_level_three_1"),
    check_passed(repo, "mcn_policy_check_1"),
    not_self_hosted_git(repo, _).


/* ------------------------------------------------------------------------- */

aggregate_level(0, repo) :-
    repository(repo, _,_,_,_,_,_).

aggregate_level(level, repo) :-
    repository(repo, name,_,_,_,_,_),
    agg_levels(level), level >= 1,
    // assert all lower level requirements to be satisfied as well
    aggregate_level(level - 1, repo),
    // assert this level requriements
    aggregate_level_requirement(level, repo),
    // dependency case
    aggregate_level_min_dependency_level(level, required_deplevel),
    min_dep_level(actual_deplevel, repo),
    actual_deplevel >= required_deplevel.

aggregate_level(level, repo) :-
    repository(repo, name,_,_,_,_,_),
    agg_levels(level), level >= 1,
    aggregate_level_requirement(level, repo),
    !dependency(repo, _).

.decl min_dep_level(level:number, repo:number)

min_dep_level(level, repo) :-
    repository(repo, _,_,_,_,_,_),
    dependency(repo, dep),
    aggregate_level(level, dep).

// minimum dep level
min_dep_level(level, repo) <= min_dep_level(mlevel, repo) :- mlevel < level.

// get maximum aggregate_level
aggregate_level(level, repo) <=  aggregate_level(glevel, repo) :- glevel > level.

//.output aggregate_level
//.output min_dep_level

//aggregate_level(level - 1, repo) :-
//    aggregate_level(level, repo), level > 0.
//
//.output aggregate_level

// only allowed outputs for test
.output passed_policies
.output failed_policies
