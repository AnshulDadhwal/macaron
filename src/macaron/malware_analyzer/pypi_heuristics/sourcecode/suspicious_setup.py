# Copyright (c) 2024 - 2024, Oracle and/or its affiliates. All rights reserved.
# Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl/.

"""This analyzer checks the suspicious pattern within setup.py."""

import ast
import logging
import os
import re
import tarfile
import tempfile
import zipfile

import requests
from requests import RequestException

from macaron.malware_analyzer.pypi_heuristics.base_analyzer import BaseHeuristicAnalyzer
from macaron.malware_analyzer.pypi_heuristics.heuristics import HeuristicResult, Heuristics
from macaron.slsa_analyzer.package_registry.pypi_registry import PyPIRegistry

logger: logging.Logger = logging.getLogger(__name__)


class SuspiciousSetupAnalyzer(BaseHeuristicAnalyzer):
    """Analyzer checks heuristic."""

    def __init__(self) -> None:
        super().__init__(name="suspicious_setup_analyzer", heuristic=Heuristics.SUSPICIOUS_SETUP, depends_on=None)
        self.blacklist: list = ["base64", "request"]

    def _get_setup_source_code(self, api_client: PyPIRegistry) -> str | None:
        """Get the source code in setup.py.

        Parameters
        ----------
        api_client: PyPIRegistry
            The API client to use for source code retrieval.

        Returns
        -------
        str | None
            The source code.
        """
        sourcecode_url: str | None = api_client.get_sourcecode_url()
        if sourcecode_url is None:
            return None

        # Create a temporary directory to store the downloaded source.
        with tempfile.TemporaryDirectory() as temp_dir:
            try:
                response = requests.get(sourcecode_url, stream=True, timeout=40)
                response.raise_for_status()
            except requests.exceptions.HTTPError as http_err:
                logger.debug("HTTP error occurred: %s", http_err)
                return None

            if response.status_code != 200:
                return None

            source_file = os.path.join(temp_dir, "tmp")
            with open(source_file, "wb") as file:
                try:
                    for chunk in response.iter_content():
                        file.write(chunk)
                except RequestException as error:
                    # Something went wrong with the request, abort.
                    logger.debug("Error while streaming source file: %s", error)
                    response.close()
                    return None

            target_file = "setup.py"
            try:
                with tarfile.open(source_file, "r:gz") as tar:
                    tar.extract(target_file)
            except tarfile.ReadError as exception:
                logger.debug("Error reading tar file: %s", exception)

                try:
                    with zipfile.ZipFile(source_file, "r") as zip_ref:
                        zip_ref.extract(target_file)
                except zipfile.BadZipFile as bad_zip_exception:
                    logger.debug("Error reading zip file: %s", bad_zip_exception)
                except zipfile.LargeZipFile as large_zip_exception:
                    logger.debug("Zip file too large to read: %s", large_zip_exception)

            final_path = os.path.join(temp_dir, target_file)
            if not os.path.exists(final_path):
                logger.debug("Failed to download source file.")
                return None

            with open(final_path, encoding="utf-8") as file:
                return file.read()

    def analyze(self, api_client: PyPIRegistry) -> tuple[HeuristicResult, dict]:
        """Analyze suspicious packages are imported in setup.py.

        Parameters
        ----------
        api_client: PyPIRegistry
            The API client to use for analysis.

        Returns
        -------
        tuple[HeuristicResult, dict]
            The Result and details.
        """
        content: str | None = self._get_setup_source_code(api_client)
        if content is None:
            return HeuristicResult.SKIP, {}

        imports = set()
        # Catch the imported module.
        try:
            tree = ast.parse(content)
            for node in ast.walk(tree):
                if isinstance(node, ast.Import):
                    for alias in node.names:
                        imports.add(alias.name)
                elif isinstance(node, ast.ImportFrom):
                    module = node.module
                    if node.level > 0 and module:
                        _module = "." * node.level + module
                        for alias in node.names:
                            if alias.name:
                                import_name = _module + "." + alias.name
                                imports.add(import_name)
        except SyntaxError:
            pattern_import = r"(?:import\s+)(\w+(?:(?:\.{1}|(?:\s*,\s*))\w+)*)(?:(?:\s|#).*)?"
            # Allows for a standard import statement.
            # E.g.: import <module_name(s)> <other_text>
            # Where <module_name(s)> consists of one or more <module_name>.
            # Where <module_name> consists of one or more words (a-z or 0-9 or underscore) separated by periods.
            # Where <other_text> allows any character(s) either after a single space or a hash (#).

            pattern_from_import = r"(?:from\s+)(\w+(?:\.{1}\w+)*)(?:\s+import\s+\w+).*"
            # Allows for a from import statement.
            # E.g.: from <module_name> import <other_text>
            # Where <module_name> is as above. (Note only a single module can be placed here.)
            # Where <other_text> requires at least one space followed by one or more word characters, plus
            # any other characters following on from that.

            combined_pattern = f"^(?:{pattern_import})|(?:{pattern_from_import})$"
            # The combined pattern creates two match groups:
            # 1 - standard import statement.
            # 2 - from import statement.

            for line in content.splitlines():
                line.strip()
                match = re.match(combined_pattern, line)
                if match:
                    if match.group(1):
                        # Standard import, handle commas if present.
                        splits = match.group(1).split(",")
                        for split in splits:
                            split = split.strip()
                            if split:
                                imports.add(split)
                    elif match.group(2):
                        # From import
                        imports.add(match.group(2))

        # Catch the install_requires packages
        pattern = r"install_requires\s*=\s*\[(.*?)\]"
        matches = re.search(pattern, content, re.DOTALL)
        if matches:
            imports.update(set(re.findall(r"'(.*?)'", matches.group(1))))

        suspicious_setup = any(suspicious_keyword in imp for imp in imports for suspicious_keyword in self.blacklist)
        if suspicious_setup:
            return HeuristicResult.FAIL, {"import_module": imports}
        return HeuristicResult.PASS, {"import_module": imports}
