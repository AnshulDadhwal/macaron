# Copyright (c) 2024 - 2024, Oracle and/or its affiliates. All rights reserved.
# Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl/.

"""This analyzer checks the suspicious pattern within setup.py."""

import ast
import logging
import os
import re
import tarfile
import tempfile
import zipfile

import requests
from requests import RequestException

from macaron.malware_analyzer.pypi_heuristics.base_analyzer import BaseHeuristicAnalyzer
from macaron.malware_analyzer.pypi_heuristics.heuristics import HeuristicResult, Heuristics
from macaron.slsa_analyzer.package_registry.pypi_registry import PyPIRegistry

logger: logging.Logger = logging.getLogger(__name__)


class SuspiciousSetupAnalyzer(BaseHeuristicAnalyzer):
    """Analyzer checks heuristic."""

    def __init__(self) -> None:
        super().__init__(name="suspicious_setup_analyzer", heuristic=Heuristics.SUSPICIOUS_SETUP, depends_on=None)
        self.blacklist: list = ["base64", "request"]

    def _get_setup_source_code(self, api_client: PyPIRegistry) -> str | None:
        """Get the source code in setup.py.

        Parameters
        ----------
        api_client: PyPIRegistry
            The API client to use for source code retrieval.

        Returns
        -------
        str | None
            The source code.
        """
        sourcecode_url: str | None = api_client.get_sourcecode_url()
        if sourcecode_url is None:
            return None

        # Create a temporary directory to store the downloaded source.
        with tempfile.TemporaryDirectory() as temp_dir:
            try:
                response = requests.get(sourcecode_url, stream=True, timeout=40)
                response.raise_for_status()
            except requests.exceptions.HTTPError as http_err:
                logger.debug("HTTP error occurred: %s", http_err)
                return None

            if response.status_code != 200:
                return None

            source_file = os.path.join(temp_dir, "tmp")
            with open(source_file, "wb") as file:
                try:
                    for chunk in response.iter_content():
                        file.write(chunk)
                except RequestException as error:
                    # Something went wrong with the request, abort.
                    logger.debug("Error while streaming source file: %s", error)
                    response.close()
                    return None

            target_file = "setup.py"
            try:
                with tarfile.open(source_file, "r:gz") as tar:
                    tar.extract(target_file)
            except tarfile.ReadError as exception:
                logger.debug("Error reading tar file: %s", exception)

                try:
                    with zipfile.ZipFile(source_file, "r") as zip_ref:
                        zip_ref.extract(target_file)
                except zipfile.BadZipFile as bad_zip_exception:
                    logger.debug("Error reading zip file: %s", bad_zip_exception)
                except zipfile.LargeZipFile as large_zip_exception:
                    logger.debug("Zip file too large to read: %s", large_zip_exception)

            final_path = os.path.join(temp_dir, target_file)
            if not os.path.exists(final_path):
                logger.debug("Source file could not be extracted from downloaded archive.")
                return None

            with open(final_path, encoding="utf-8") as file:
                return file.read()

    def analyze(self, api_client: PyPIRegistry) -> tuple[HeuristicResult, dict]:
        """Analyze suspicious packages are imported in setup.py.

        Parameters
        ----------
        api_client: PyPIRegistry
            The API client to use for analysis.

        Returns
        -------
        tuple[HeuristicResult, dict]
            The Result and details.
        """
        content: str | None = self._get_setup_source_code(api_client)
        if content is None:
            return HeuristicResult.SKIP, {}

        # Catch the imported module.
        try:
            imports = self.extract_from_ast(content)
        except SyntaxError:
            imports = self.extract_from_lines(content)

        # Catch the install_requires packages
        pattern = r"install_requires\s*=\s*\[(.*?)\]"
        matches = re.search(pattern, content, re.DOTALL)
        if matches:
            imports.update(set(re.findall(r"'(.*?)'", matches.group(1))))

        suspicious_setup = any(suspicious_keyword in imp for imp in imports for suspicious_keyword in self.blacklist)
        if suspicious_setup:
            return HeuristicResult.FAIL, {"import_module": imports}
        return HeuristicResult.PASS, {"import_module": imports}

    def extract_from_ast(self, source_content: str) -> set[str]:
        """Extract imports from source code using the parsed AST.

        Parameters
        ----------
        source_content: str
            The source code as a string.

        Returns
        -------
        set[str]
            The set of imports.

        Raises
        ------
        SyntaxError
            If the code could not be parsed.
        """
        imports = set()
        tree = ast.parse(source_content)
        for node in ast.walk(tree):
            if isinstance(node, ast.Import):
                for alias in node.names:
                    imports.add(alias.name)
            elif isinstance(node, ast.ImportFrom):
                module = node.module
                if module:
                    imports.add("." * node.level + module)

        return imports

    def extract_from_lines(self, source_content: str) -> set[str]:
        """Extract imports from source code using per line pattern matching.

        Parameters
        ----------
        source_content: str
            The source code as a string.

        Returns
        -------
        set[str]
            The list of imports.
        """
        alias_pattern = r"\s+as\s+\w+(?:\.{0,1}\w+)*"
        # Pattern for module aliases.

        module_name = r"\w+(?:\.{0,1}\w+"
        # <module_name> as described under pattern_import.

        pattern_import = (
            r"(?:import\s+)(" + module_name + r")*(?:" + alias_pattern + r")?"
            r"(?:(?:\s*,\s*)(?:" + module_name + r")*(?:" + alias_pattern + r")?))*)(?:(?:\s|#).*)?"
        )
        # Allows for a standard import statement.
        # E.g.: import <module_name(s)> <other_text>
        # Where <module_name(s)> consists of one or more <module_name>.
        # Where <module_name> consists of one or more words (a-z or 0-9 or underscore) separated by periods,
        # with an optional alias.
        # Where <other_text> allows any character(s) either after a single space or a hash (#).

        pattern_from_import = r"(?:from\s+)([.]*\w+(?:\.{1}\w+)*)(?:\s+import\s+\w+).*"
        # Allows for a from import statement.
        # E.g.: from <module_name> import <other_text>
        # Where <module_name> is as above. (Note only a single module can be placed here.)
        # Where <other_text> requires at least one space followed by one or more word characters, plus
        # any other characters following on from that.

        combined_pattern = f"^(?:{pattern_import})|(?:{pattern_from_import})$"
        # The combined pattern creates two match groups:
        # 1 - standard import statement.
        # 2 - from import statement.

        imports = set()
        for line in source_content.splitlines():
            line.strip()
            match = re.match(combined_pattern, line)
            if not match:
                continue

            if match.group(1):
                # Standard import, handle commas and aliases if present.
                splits = match.group(1).split(",")
                for split in splits:
                    split = split.strip()
                    # Remove aliases
                    split = re.sub(alias_pattern, "", split)
                    if split:
                        imports.add(split)
            elif match.group(2):
                # From import
                imports.add(match.group(2))

        return imports
